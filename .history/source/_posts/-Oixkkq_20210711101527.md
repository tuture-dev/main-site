---
title: "从零到部署：用 Vue 和 Express 实现迷你全栈电商应用（六）"
description: "前面五篇教程我们已经基本实现了迷你全栈电商应用的界面展示以及功能逻辑，相信大家在这个过程中都收获颇丰，并且迈向了全栈工程师的第一步。但是我们却并不满足于此，我们还需要对我们的项目代码进行优化，使得我们的代码可读性更高，也更好维护。相信细心的你们已经感觉到了项目中的store实例实在是过于臃肿，因此，本篇教程就是带大家一起学习如何抽出 Getters 、 Mutations 和Actions 逻辑实现store的“减重”以及如何干掉 mutation-types 硬编码。"
tags: ["Vue", "Vuex"]
categories: ["前端", "Vue", "入门"]
date: 2020-03-03T00:00:00.509Z
photos:
  - https://static.tuture.co/c/092faf4/cover-6.jpg
---

<div class="profileBox">
  <div class="avatarBox">
    <a href="https://github.com/tuture-dev"><img src="/images/avatars/tuture-dev.jpg" alt="" class="avatar"></a>
  </div>
  <div class="rightBox">
    <div class="infoBox">
    <a href="https://github.com/tuture-dev"><p class="nickName">@tuture-dev</p></a>
  </div>
  <div class="codeBox">
    <a href="https://github.com/tuture-dev/vue-online-shop-frontend"><span class="codeText">查看代码</span></a>
  </div>
  </div>
</div>

## 抽出 Getters 和 Mutations 逻辑

这一节我们来学习如何抽出在`store`实例中定义的复杂`getters`和`mutation`逻辑。

我们发现之前我们直接把所有的`getter`属性和方法都定义在了`store`实例中的`getters`属性中，所有的`mutation`属性也都定义在了`store`实例中的`mutations`属性中，这样显得`store`实例特别的累赘，因此我们可以通过对象展开运算符将这些复杂的逻辑抽取到对应的 `Getters` 和 `Mutations`文件中。

### 重构 Admin 入口文件

首先我们做一点本土化，把之前的 `src/pages/admin/Index.vue` 中的英文导航改成中文版，方便查看；并且我们增加了查看生产商导航。

```html src/pages/admin/Index.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/f0b5684/src/pages/admin/Index.vue 查看完整代码
<template>
  <div>
    <div class="admin-new">
      <div class="container">
        <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12">
          <ul class="admin-menu">
            <li>
[tuture-del]              <router-link to="/admin">View Products</router-link>
[tuture-add]              <router-link to="/admin">查看商品</router-link>
            </li>
            <li>
[tuture-del]              <router-link to="/admin/new">New Products</router-link>
[tuture-add]              <router-link to="/admin/new">添加商品</router-link>
[tuture-add]            </li>
[tuture-add]            <li>
[tuture-add]              <router-link to="/admin/manufacturers">查看生产商</router-link>
            </li>
          </ul>
        </div>
        <router-view></router-view>
      </div>
    </div>
  </div>
</template>
```

这里我们将有关商品的导航栏修改为中文版，让用户能够秒懂；除此之外我们又添加了有关制造商的导航，这里增加的是**查看生产商**导航，并添加了对应的导航跳转路径，该路径需要与对应路由参数一致。

### 创建 Manufacturers 组件

我们创建的`src/pages/admin/Manufacturers.vue`文件是本地制造商组件，用于展示制造商的信息。

```html src/pages/admin/Manufacturers.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/f0b5684/src/pages/admin/Manufacturers.vue 查看完整代码
<template>
  <div>
    <table class="table">
      <thead>
        <tr>
          <th>制造商</th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="manufacturer in manufacturers" :key="manufacturer._id">
          <td>{{manufacturer.name}}</td>
          <td class="modify"><router-link :to="'/admin/manufacturers/edit/' + manufacturer._id">修改</router-link></td>
          <td class="remove"><a @click="removeManufacturer(manufacturer._id)" href="#">删除</a></td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<style>
table {
  margin: 0 auto;
}

.modify {
  color: blue;
}

.remove a {
  color: red;
}
</style>

<script>
export default {
  created() {
    if (this.manufacturers.length === 0) {
      this.$store.dispatch('allManufacturers');
    }
  },
  computed: {
    manufacturers() {
      return this.$store.getters.allManufacturers
    }
  },
  methods: {
    removeManufacturer(manufacturerId) {
      // 使用 JavaScript BOM 的 confirm 方法来询问用户是否删除此制造商
      const res = confirm('是否删除此制造商？');

      // 如果用户同意，那么就删除此制造商
      if (res) {
        this.$store.dispatch('removeManufacturer', {
          manufacturerId,
        })
      }
    }
  }
}
</script>
```

这里首先定义了一个计算属性`manufacturers`，通过`this.$store.getters.allManufacturers`属性访问的形式调用对应的`getter`属性`allManufacturers`从本地获取`manufacturers`，并返回给计算属性`manufacturers`。

然后在该组件刚被创建时判断本地中是否存在`manufacturers`，如果没有则通过`this.$store.dispatch`分发到类型为`allManufacturers`的`action`中进行异步操作获取所有制造商，并将获取的制造商提交到对应的`mutation`中，在`mutation`中修改本地状态，将获取的所有制造商保存到本地。

最后利用`v-for`在表格中遍历`manufacturers`，每个制造商的信息在一行展示，除了信息之外还有两个功能（修改和删除制造商），点击修改则会根据`'/admin/manufacturers/edit/' + manufacturer._id`路由到指定页面；点击删除则会触发`removeManufacturer`事件，首先询问用户是否同意删除，若用户同意则将选中制造商的id作为载荷分发到类型为`removeManufacturer`的`action`中，在`action`中进行异步操作删除后端对应商品，并将对应商品id提交到对应的`mutation`中，在`mutation`中进行本地状态修改，删除本地对应的商品。

### 重构 Products 组件

根据`Manufacturers`组件的设计原则，我们需要再次进入`src/pages/admin/Products.vue`文件。按照`Manufacturers`组件的UI展示以及数据处理，将`Products`组件进行一下重构。

```html src/pages/admin/Products.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/f0b5684/src/pages/admin/Products.vue 查看完整代码
<template>
  <div>
[tuture-del]    <div class="title">
[tuture-del]      <h1>This is Admin</h1>
[tuture-del]    </div>
[tuture-del]    <div class="body">
[tuture-del]      {{ product.name }}
[tuture-del]    </div>
[tuture-add]    <table class="table">
[tuture-add]      <thead>
[tuture-add]        <tr>
[tuture-add]          <th>名称</th>
[tuture-add]          <th>价格</th>
[tuture-add]          <th>制造商</th>
[tuture-add]          <th></th>
[tuture-add]          <th></th>
[tuture-add]        </tr>
[tuture-add]      </thead>
[tuture-add]      <tbody>
[tuture-add]        <tr v-for="product in products" :key="product._id">
[tuture-add]          <td>{{product.name}}</td>
[tuture-add]          <td>{{product.price}}</td>
[tuture-add]          <td>{{product.manufacturer.name}}</td>
[tuture-add]          <td class="modify"><router-link :to="'/admin/edit/' + product._id">修改</router-link></td>
[tuture-add]          <td class="remove"><a @click="removeProduct(product._id)" href="#">删除</a></td>
[tuture-add]        </tr>
[tuture-add]      </tbody>
[tuture-add]    </table>
  </div>
</template>

[tuture-add]<style>
[tuture-add]table {
[tuture-add]  margin: 0 auto;
[tuture-add]}
[tuture-add] 
[tuture-add].modify {
[tuture-add]  color: blue;
[tuture-add]}
[tuture-add] 
[tuture-add].remove a {
[tuture-add]  color: red;
[tuture-add]}
[tuture-add]</style>
[tuture-add] 
<script>
export default {
[tuture-add]  created() {
[tuture-add]    if (this.products.length === 0) {
[tuture-add]      this.$store.dispatch('allProducts');
[tuture-add]    }
[tuture-add]  },
  computed: {
[tuture-del]    product() {
[tuture-del]      return this.$store.getters.allProducts[0];
[tuture-add]    products() {
[tuture-add]      return this.$store.getters.allProducts
[tuture-add]    }
[tuture-add]  },
[tuture-add]  methods: {
[tuture-add]    removeProduct(productId) {
[tuture-add]      // 使用 JavaScript BOM 的 confirm 方法来询问用户是否删除此商品
[tuture-add]      const res = confirm('是否删除此商品？');
[tuture-add] 
[tuture-add]      // 如果用户同意，那么就删除此商品
[tuture-add]      if (res) {
[tuture-add]        this.$store.dispatch('removeProduct', {
[tuture-add]          productId,
[tuture-add]        })
[tuture-add]      }
    }
  }
}
// ...
```

这部分代码逻辑与`src/pages/admin/Manufacturers.vue`文件中的代码逻辑相似，如果您理解了上面的代码逻辑，那么我们相信您对这里的代码也能融会贯通，所以这里就不再赘述了。

### 添加路由信息

我们已经创建了有关制造商的导航以及查看制造商组件，还需对其配置相应的路由参数才能实现跳转。因此再次进入`src/router/index.js`文件，这里我们导入了制造商组件并增加了制造商相关路由参数。

```js src/router/index.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/f0b5684/src/router/index.js 查看完整代码
// ...
import New from '@/pages/admin/New';
import Products from '@/pages/admin/Products';
import Edit from '@/pages/admin/Edit';
[tuture-add]import Manufacturers from '@/pages/admin/Manufacturers';

Vue.use(Router);

// ...
          name: 'Edit',
          component: Edit,
        },
[tuture-add]        {
[tuture-add]          path: 'manufacturers',
[tuture-add]          name: 'Manufacturers',
[tuture-add]          component: Manufacturers,
[tuture-add]        },
      ]
    },
    {
      // ...
```

把项目跑起来，点击`Admin`然后再点击**查看生产商**，我们可以看到从后端获取的所有生产商：  下面展示的就是从后端获取的制造商，并且我们可以对其进行修改和删除操作。

![](https://imgkr2.cn-bj.ufileos.com/11f291f4-daa2-4d7b-80a3-305fd8840cef.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=bUlzaK1%252BPpuYQhfzNYPVKpxfx9k%253D&Expires=1597417587)

### 抽取 Getters 逻辑

我们首先创建了`src/store/getters.js`文件，用于存放各种不同类型的`getter`属性和方法。这里我们导出了两个对象分别为`productGetters`和`manufacturerGetters`，前者包含了有关商品的`getter`属性与方法，后者包含了有关制造商的`getter`属性与方法。

```js src/store/getters.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/f0b5684/src/store/getters.js 查看完整代码
export const productGetters = {
  allProducts(state) {
    return state.products
  },
  productById: (state, getters) => id => {
    if (getters.allProducts.length > 0) {
      return getters.allProducts.filter(product => product._id === id)[0]
    } else {
      return state.product;
    }
  }
}

export const manufacturerGetters = {
  allManufacturers(state) {
    return state.manufacturers;
  }
}
```

在`productGetters`对象中定义的就是有关商品的`getter`属性和方法，如`allProducts`，`productById`等等；在`manufacturerGetters`对象中定义的就是有关制造商的`getter`属性和方法，如`allManufacturers`等等。

> 我们可以采用属性调用和方法调用的方式调用这里的getter(根据我们在getter对象中定义的是属性还是方法)

### 抽取 Mutations 逻辑

同样的我们创建了`src/store/mutations.js`文件，用于存放从`store`实例的`mutations`属性中抽取出来的各种`mutation`属性，这里我们定义了三个对象分别为`productMutations`，`cartMutations`以及`manufacturerMutations `。

```js src/store/mutations.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/f0b5684/src/store/mutations.js 查看完整代码
export const productMutations = {
  ALL_PRODUCTS(state) {
    state.showLoader = true;
  },
  ALL_PRODUCTS_SUCCESS(state, payload) {
    const { products } = payload;

    state.showLoader = false;
    state.products = products;
  },
  PRODUCT_BY_ID(state) {
    state.showLoader = true;
  },
  PRODUCT_BY_ID_SUCCESS(state, payload) {
    state.showLoader = false;

    const { product } = payload;
    state.product = product;
  },
  REMOVE_PRODUCT(state) {
    state.showLoader = true;
  },
  REMOVE_PRODUCT_SUCCESS(state, payload) {
    state.showLoader = false;

    const { productId } = payload;
    state.products = state.products.filter(product => product._id !== productId);
  }
};

export const cartMutations = {
  ADD_TO_CART(state, payload) {
    const { product } = payload;
    state.cart.push(product)
  },
  REMOVE_FROM_CART(state, payload) {
    const { productId } = payload
    state.cart = state.cart.filter(product => product._id !== productId)
  },
}

export const manufacturerMutations = {
  ALL_MANUFACTURERS(state) {
    state.showLoader = true;
  },
  ALL_MANUFACTURERS_SUCCESS(state, payload) {
    const { manufacturers } = payload;

    state.showLoader = false;
    state.manufacturers = manufacturers;
  },
  REMOVE_MANUFACTURER(state) {
    state.showLoader = true;
  },
  REMOVE_MANUFACTURER_SUCCESS(state, payload) {
    state.showLoader = false;

    const { manufacturerId } = payload;
    state.manufacturers = state.manufacturers.filter(manufacturer => manufacturer._id !== manufacturerId);
  }
}
```

在`productMutations`对象中定义了有关商品响应Vue视图层以及`avtion`中提交的事件，比如`ALL_PRODUCTS`，`ALL_PRODUCTS_SUCCESS`，`PRODUCT_BY_ID`以及`PRODUCT_BY_ID_SUCCESS`等等。

在`cartMutations`对象中定义了有关购物车响应Vue视图层提交的事件，比如`ADD_TO_CART`，`REMOVE_FROM_CART`等等。

在`manufacturerMutations `对象中定义了有关制造商响应Vue视图层以及`avtion`中提交的事件，比如`ALL_MANUFACTURERS`，`ALL_MANUFACTURERS_SUCCESS`，`REMOVE_MANUFACTURER`以及`REMOVE_MANUFACTURER_SUCCESS`等等。

### 重构 Store 实例

我们将`store`实例中的`Getter`属性和`Mutation`属性抽出之后要再进行导入。再回到`src/store/index.js`文件，这里就是抽离`getters`和`mutations`逻辑之后的`store`实例，看起来是不是轻盈了很多，也增强了代码的可读性。

```js src/store/index.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/f0b5684/src/store/index.js 查看完整代码
// ...
import Vuex from 'vuex';
import axios from 'axios';

[tuture-add]import { productGetters, manufacturerGetters } from './getters';
[tuture-add]import { productMutations, cartMutations, manufacturerMutations } from './mutations';
[tuture-add] 
const API_BASE = 'http://localhost:3000/api/v1';

Vue.use(Vuex);
 // ...
    manufacturers: [],
  },
  mutations: {
[tuture-del]    ADD_TO_CART(state, payload) {
[tuture-del]      const { product } = payload;
[tuture-del]      state.cart.push(product)
[tuture-del]    },
[tuture-del]    REMOVE_FROM_CART(state, payload) {
[tuture-del]      const { productId } = payload
[tuture-del]      state.cart = state.cart.filter(product => product._id !== productId)
[tuture-del]    },
[tuture-del]    ALL_PRODUCTS(state) {
[tuture-del]      state.showLoader = true;
[tuture-del]    },
[tuture-del]    ALL_PRODUCTS_SUCCESS(state, payload) {
[tuture-del]      const { products } = payload;
[tuture-del] 
[tuture-del]      state.showLoader = false;
[tuture-del]      state.products = products;
[tuture-del]    },
[tuture-del]    PRODUCT_BY_ID(state) {
[tuture-del]      state.showLoader = true;
[tuture-del]    },
[tuture-del]    PRODUCT_BY_ID_SUCCESS(state, payload) {
[tuture-del]      state.showLoader = false;
[tuture-del] 
[tuture-del]      const { product } = payload;
[tuture-del]      state.product = product;
[tuture-del]    }
[tuture-add]    ...productMutations,
[tuture-add]    ...cartMutations,
[tuture-add]    ...manufacturerMutations,
  },
  getters: {
[tuture-del]    allProducts(state) {
[tuture-del]      return state.products;
[tuture-del]    },
[tuture-del]    productById: (state, getters) => id => {
[tuture-del]      if (getters.allProducts.length > 0) {
[tuture-del]        return getters.allProducts.filter(p => p._id == id)[0];
[tuture-del]      } else {
[tuture-del]        return state.product;
[tuture-del]      }
[tuture-del]    }
[tuture-add]    ...productGetters,
[tuture-add]    ...manufacturerGetters,
  },
  actions: {
    allProducts({ commit }) {
      // ...
          product: response.data,
        });
      })
[tuture-del]    }
[tuture-add]    },
[tuture-add]    removeProduct({ commit }, payload) {
[tuture-add]      commit('REMOVE_PRODUCT');
[tuture-add] 
[tuture-add]      const { productId } = payload;
[tuture-add]      axios.delete(`${API_BASE}/products/${productId}`).then(() => {
[tuture-add]        // 返回 productId，用于删除本地对应的商品
[tuture-add]        commit('REMOVE_PRODUCT_SUCCESS', {
[tuture-add]          productId,
[tuture-add]        });
[tuture-add]      })
[tuture-add]    },
[tuture-add]    allManufacturers({ commit }) {
[tuture-add]      commit('ALL_MANUFACTURERS');
[tuture-add] 
[tuture-add]      axios.get(`${API_BASE}/manufacturers`).then(response => {
[tuture-add]        commit('ALL_MANUFACTURERS_SUCCESS', {
[tuture-add]          manufacturers: response.data,
[tuture-add]        });
[tuture-add]      })
[tuture-add]    },
[tuture-add]    removeManufacturer({ commit }, payload) {
[tuture-add]      commit('REMOVE_MANUFACTURER');
[tuture-add] 
[tuture-add]      const { manufacturerId } = payload;
[tuture-add]      axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() => {
[tuture-add]        // 返回 manufacturerId，用于删除本地对应的制造商
[tuture-add]        commit('REMOVE_MANUFACTURER_SUCCESS', {
[tuture-add]          manufacturerId,
[tuture-add]        });
[tuture-add]      })
[tuture-add]    },
  }
});
```

这里首先导入了`getters`和`mutations`文件中导出的所有对象，然后在`store`实例的`getters`和`mutations`属性中通过对象展开运算符的方式将对应的属性和方法导入到`store`实例中。

> **对象展开运算符**是ES7草案中的新特性，将一个对象当中的对象的一部分取出来成为一个新对象赋值给展开运算符的参数，然后插入到另外一个对象当中。例如：

```javascript
let shortcuts = {
    attr1: 3,
    attr2: 4
}
let shortcuts2 = {}
shortcuts2 = {...shortcuts}

//上面的这种用法实际上相当于是：
shortcuts2 = {attr1: 3, attr2: 4}
```

除此之外我们又在`actions`中添加了一些其他的`action`属性，因为此时`actions`还未被抽离，所以可能依然显得有些臃肿，不过在后面我们马上也会将它抽离出来。

### 小结

这一节我们学习了如何抽出`Getters`和`Mutations`逻辑，减轻`store`实例中的负载：

- 首先我们需要分别创建`getters`和`mutations`JS文件，在两个JS文件中分别定义不同类型的`getters`和`mutations`对象并导出，然后在`getters`和`mutations`对象中定义相应的一些属性和方法。
- 在`store`的`index`文件中导入这些`getters`和`mutations`对象，并在`store`实例的`getters`和`mutations`属性中通过对象展开运算符混入这些对象。
- 我们可以使用`this.$store.getters.属性`和`this.$store.mutations.属性`的方式调用.

## 抽出 Actions 逻辑

上一节我们学习了如何抽出`Getters`和`Mutations`逻辑，这一节我们以同样的方式抽出`Actions`逻辑。

### 重构 Edit 组件

`src/pages/admin/Edit.vue`是商品编辑组件，当触发`'/admin/edit/' + product._id`就会路由到指定商品信息编辑页面，然后对商品信息进行修改。

之前我们直接将展示商品信息的代码放在该组件中，但是我们发现展示商品信息这部分功能在新建商品和编辑商品组件中都需要使用，因此我们打算把这部分代码封装为一个展示商品信息的表单组件`ProductForm`，这样的话我们在新建商品和编辑商品组件中都能复用该组件。

除此之外我们还在该组件中添加了数据处理功能。

```html src/pages/admin/Edit.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/4909803/src/pages/admin/Edit.vue 查看完整代码
<template>
  <div>
    <div class="title">
[tuture-del]      <h1>This is Admin/Edit/{{$route.params.id}}</h1>
[tuture-add]      <h1>This is Admin/Edit</h1>
    </div>
[tuture-add]    <product-form
[tuture-add]      @save-product="updateProduct"
[tuture-add]      :model="model"
[tuture-add]      :manufacturers="manufacturers"
[tuture-add]      :isEditing="true"
[tuture-add]      ></product-form>
  </div>
</template>
[tuture-add] 
[tuture-add]<script>
[tuture-add]import ProductForm from '@/components/products/ProductForm.vue';
[tuture-add]export default {
[tuture-add]  created() {
[tuture-add]    const { name } = this.model;
[tuture-add]    if (!name) {
[tuture-add]      this.$store.dispatch('productById', {
[tuture-add]        productId: this.$route.params['id']
[tuture-add]      });
[tuture-add]    }
[tuture-add] 
[tuture-add]    if (this.manufacturers.length === 0) {
[tuture-add]      this.$store.dispatch('allManufacturers');
[tuture-add]    }
[tuture-add]  },
[tuture-add]  computed: {
[tuture-add]    manufacturers() {
[tuture-add]      return this.$store.getters.allManufacturers;
[tuture-add]    },
[tuture-add]    model() {
[tuture-add]      const product = this.$store.getters.productById(this.$route.params['id']);
[tuture-add] 
[tuture-add]      // 这里返回 product 的拷贝，是为了在修改 product 的拷贝之后，在保存之前不修改本地 Vuex stire 的 product 属性
[tuture-add]      return { ...product, manufacturer: { ...product.manufacturer } };
[tuture-add]    }
[tuture-add]  },
[tuture-add]  methods: {
[tuture-add]    updateProduct(product) {
[tuture-add]      this.$store.dispatch('updateProduct', {
[tuture-add]        product,
[tuture-add]      })
[tuture-add]    }
[tuture-add]  },
[tuture-add]  components: {
[tuture-add]    'product-form': ProductForm
[tuture-add]  }
[tuture-add]}
[tuture-add]</script>
```

我们先来看该组件的`script`部分，首先定义了两个计算属性`model`和`manufacturers`返回本地商品和制造商。通过方法访问的方式调用指定的`getter`属性`productById`，参数为当前处于激活状态的路由对象的id，这里返回`product`的拷贝，是为了在修改 `product`的拷贝之后，在保存之前不修改本地 Vuex store 的`product`属性。计算属性`manufacturers`通过相同的方式获取本地数据。

当该组件刚被创建时判断计算属性`model`中是否有值，如果没有则表示本地中没有该商品，将包含该商品id的对象作为载荷分发到类型为`productById`的`action`中，在`action`中进行异步操作从后端获取对应商品，并提交到对应类型的`mutation`中，在`mutation`中将获取到的商品保存到本地。除此之外判断计算属性`manufacturers`中是否有值，如果没有则通过相同的方式从后端获取并保存到本地。

在`template`中使用了子组件`ProductForm`用表单的形式来展示商品信息，当用户提交表单则会向父组件发射`save-product`事件，父组件监听到之后触发`updateProduct`事件，并将传入的商品参数作为载荷分发到类型为`updateProduct`的`action`中，通知后端进行同步更新数据并提交到对应的`mutation`中进行本地数据更新。

### 重构 New 组件

`src/pages/admin/New.vue`是添加商品组件，与`Edit`组件的代码逻辑相似，只是一个是修改商品信息，一个是添加商品信息。

我们将该组件中原先写死的数据改成了从后端动态获取， 并将获取的数据传递给子组件`ProductForm。`

```html src/pages/admin/New.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/4909803/src/pages/admin/New.vue 查看完整代码
<template>
  <product-form
    @save-product="addProduct"
    :model="model"
    :manufacturers="manufacturers"
  >
  </product-form>
</template>

<script>
import ProductForm from '@/components/products/ProductForm.vue';
export default {
[tuture-del]  data() {
[tuture-del]    return {
[tuture-del]      model: {},
[tuture-del]      manufacturers: [
[tuture-del]        {
[tuture-del]          _id: 'sam',
[tuture-del]          name: 'Samsung',
[tuture-del]        },
[tuture-del]        {
[tuture-del]          _id: 'apple',
[tuture-del]          name: 'Apple',
[tuture-del]        },
[tuture-del]      ],
[tuture-del]    };
[tuture-add]  created() {
[tuture-add]    if (this.manufacturers.length === 0) {
[tuture-add]      this.$store.dispatch('allManufacturers');
[tuture-add]    }
[tuture-add]  },
[tuture-add]  computed: {
[tuture-add]    manufacturers() {
[tuture-add]      return this.$store.getters.allManufacturers;
[tuture-add]    },
[tuture-add]    model() {
[tuture-add]      return {};
[tuture-add]    }
  },
  methods: {
    addProduct(model) {
[tuture-del]      console.log('model', model);
[tuture-add]      this.$store.dispatch('addProduct', {
[tuture-add]        product: model,
[tuture-add]      })
    },
  },
  components: {
  'product-form': ProductForm
  }
}
</script>
```

该组件代码逻辑和`Edit.vue`组件相似，只是在这里我们定义的计算属性`model`返回一个空对象作为默认值，因为我们是添加商品，本地中还不存在该商品。

### 抽取 Actions 逻辑

像之前一样我们创建了`src/store/actions.js`文件，用于存储从`store`实例的`actions`属性中抽取出来的不同类型的`action`属性。这里我们定义了两个`Actions`对象：`productActions`和`manufacturerActions`，分别表示有关商品和制造商对视图层分发的事件作出的响应，并导出了这两个对象。

```js src/store/actions.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/4909803/src/store/actions.js 查看完整代码
import axios from 'axios';

const API_BASE = 'http://localhost:3000/api/v1';

export const productActions = {
  allProducts({ commit }) {
    commit('ALL_PRODUCTS')

    axios.get(`${API_BASE}/products`).then(response => {
      commit('ALL_PRODUCTS_SUCCESS', {
        products: response.data,
      });
    })
  },
  productById({ commit }, payload) {
    commit('PRODUCT_BY_ID');

    const { productId } = payload;
    axios.get(`${API_BASE}/products/${productId}`).then(response => {
      commit('PRODUCT_BY_ID_SUCCESS', {
        product: response.data,
      });
    })
  },
  removeProduct({ commit }, payload) {
    commit('REMOVE_PRODUCT');

    const { productId } = payload;
    axios.delete(`${API_BASE}/products/${productId}`).then(() => {
      // 返回 productId，用于删除本地对应的商品
      commit('REMOVE_PRODUCT_SUCCESS', {
        productId,
      });
    })
  },
  updateProduct({ commit }, payload) {
    commit('UPDATE_PRODUCT');

    const { product } = payload;
    axios.put(`${API_BASE}/products/${product._id}`, product).then(() => {
      commit('UPDATE_PRODUCT_SUCCESS', {
        product,
      });
    })
  },
  addProduct({ commit }, payload) {
    commit('ADD_PRODUCT');

    const { product } = payload;
    axios.post(`${API_BASE}/products`, product).then(response => {
      commit('ADD_PRODUCT_SUCCESS', {
        product: response.data,
      })
    })
  }
};

export const manufacturerActions = {
  allManufacturers({ commit }) {
    commit('ALL_MANUFACTURERS');

    axios.get(`${API_BASE}/manufacturers`).then(response => {
      commit('ALL_MANUFACTURERS_SUCCESS', {
        manufacturers: response.data,
      });
    })
  },
  removeManufacturer({ commit }, payload) {
    commit('REMOVE_MANUFACTURER');

    const { manufacturerId } = payload;
    axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() => {
      // 返回 manufacturerId，用于删除本地对应的制造商
      commit('REMOVE_MANUFACTURER_SUCCESS', {
        manufacturerId,
      });
    })
  },
}
```

在该文件中我们首先导入`axios`依赖，以及定义了 `API_BASE` 后端接口根路由；

然后我们定义并导出了两个对象：

- 在`productActions`对象中定义了一些有关商品在视图层分发对应的事件时，`action`作出的响应，比如`allProducts`，`productById`，`removeProduct`以及`updateProduct`等等。
- 在`manufacturerActions`对象中定义了一些有关制造商在视图层分发对应的事件时，`action`作出的响应，比如`allManufacturers`，`removeManufacturer`等等。

### 重构 Store 实例

我们再次来到`src/store/index.js`文件中，添加有关抽取`Actions`逻辑之后的信息。

```js src/store/index.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/4909803/src/store/index.js 查看完整代码
import Vue from 'vue';
import Vuex from 'vuex';
[tuture-del]import axios from 'axios';

import { productGetters, manufacturerGetters } from './getters';
import { productMutations, cartMutations, manufacturerMutations } from './mutations';
[tuture-del] 
[tuture-del]const API_BASE = 'http://localhost:3000/api/v1';
[tuture-add]import { productActions, manufacturerActions } from './actions';

Vue.use(Vuex);

// ...
  actions: {
[tuture-del]    allProducts({ commit }) {
[tuture-del]      commit('ALL_PRODUCTS')
[tuture-del] 
[tuture-del]      axios.get(`${API_BASE}/products`).then(response => {
[tuture-del]        commit('ALL_PRODUCTS_SUCCESS', {
[tuture-del]          products: response.data,
[tuture-del]        });
[tuture-del]      })
[tuture-del]    },
[tuture-del]    productById({ commit }, payload) {
[tuture-del]      commit('PRODUCT_BY_ID');
[tuture-del] 
[tuture-del]      const { productId } = payload;
[tuture-del]      axios.get(`${API_BASE}/products/${productId}`).then(response => {
[tuture-del]        commit('PRODUCT_BY_ID_SUCCESS', {
[tuture-del]          product: response.data,
[tuture-del]        });
[tuture-del]      })
[tuture-del]    },
[tuture-del]    removeProduct({ commit }, payload) {
[tuture-del]      commit('REMOVE_PRODUCT');
[tuture-del] 
[tuture-del]      const { productId } = payload;
[tuture-del]      axios.delete(`${API_BASE}/products/${productId}`).then(() => {
[tuture-del]        // 返回 productId，用于删除本地对应的商品
[tuture-del]        commit('REMOVE_PRODUCT_SUCCESS', {
[tuture-del]          productId,
[tuture-del]        });
[tuture-del]      })
[tuture-del]    },
[tuture-del]    allManufacturers({ commit }) {
[tuture-del]      commit('ALL_MANUFACTURERS');
[tuture-del] 
[tuture-del]      axios.get(`${API_BASE}/manufacturers`).then(response => {
[tuture-del]        commit('ALL_MANUFACTURERS_SUCCESS', {
[tuture-del]          manufacturers: response.data,
[tuture-del]        });
[tuture-del]      })
[tuture-del]    },
[tuture-del]    removeManufacturer({ commit }, payload) {
[tuture-del]      commit('REMOVE_MANUFACTURER');
[tuture-del] 
[tuture-del]      const { manufacturerId } = payload;
[tuture-del]      axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() => {
[tuture-del]        // 返回 manufacturerId，用于删除本地对应的制造商
[tuture-del]        commit('REMOVE_MANUFACTURER_SUCCESS', {
[tuture-del]          manufacturerId,
[tuture-del]        });
[tuture-del]      })
[tuture-del]    },
[tuture-add]    ...productActions,
[tuture-add]    ...manufacturerActions,
  }
});
```

这里我们首先导入了`actions.js`文件中导出的一些Action对象，并通过对象展开运算符在`store`实例的`actions`属性中混入了不同类型的`action`属性，实现了Actions逻辑的抽取。

### 添加 mutations 属性

我们在`src/store/mutations.js`文件中又添加了一些`mutation`属性，用于用户进行不同的操作进行本地数据的同步。

```js src/store/mutations.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/4909803/src/store/mutations.js 查看完整代码
// ...

    const { productId } = payload;
    state.products = state.products.filter(product => product._id !== productId);
[tuture-add]  },
[tuture-add]  UPDATE_PRODUCT(state) {
[tuture-add]    state.showLoader = true;
[tuture-add]  },
[tuture-add]  UPDATE_PRODUCT_SUCCESS(state, payload) {
[tuture-add]    state.showLoader = false;
[tuture-add] 
[tuture-add]    const { product: newProduct } = payload;
[tuture-add]    state.product = newProduct;
[tuture-add]    state.products = state.products.map(product => {
[tuture-add]      if (product._id === newProduct._id) {
[tuture-add]        return newProduct;
[tuture-add]      }
[tuture-add] 
[tuture-add]      return product;
[tuture-add]    })
[tuture-add]  },
[tuture-add]  ADD_PRODUCT(state) {
[tuture-add]    state.showLoader = true;
[tuture-add]  },
[tuture-add]  ADD_PRODUCT_SUCCESS(state, payload) {
[tuture-add]    state.showLoader = false;
[tuture-add] 
[tuture-add]    const { product } = payload;
[tuture-add]    state.products = state.products.concat(product);
  }
};

// ...
```

上述添加的都是有关商品的`mutation`属性：`UPDATE_PRODUCT`，`UPDATE_PRODUCT_SUCCESS`，`ADD_PRODUCT`以及`ADD_PRODUCT_SUCCESS`分别表示更新商品信息，更新商品信息成功，添加商品以及添加商品成功。

### 小结

这一节我们学习了如何抽出`Actions`逻辑，减轻`store`实例中的负载：

- 首先我们需要创建`actions`JS文件，在文件中定义不同类型的`Actions`对象并导出，然后在`Actions`对象中定义相应的一些属性。
- 在`store`的`index`文件中导入这些`Actions`对象，并在`store`实例的`actions`属性中通过对象展开运算符混入这些对象。
- 我们可以使用`this.$store.actions.属性`的方式调用。

## 干掉 mutation-types 硬编码

这一节我们主要是进一步完善我们的项目功能以及去掉一些硬编码。

### 创建 ManufacturerForm 组件

和商品信息展示功能一样，我们也需要将制造商信息展示部分封装到一个单独的组件`ManufacturerForm`中，以便我们在新建制造商和编辑制造商组件中都能复用该组件。

因此我们创建了`src/components/ManufacturerForm.vue`文件，用于展示制造商信息的表单组件。

```html src/components/ManufacturerForm.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/components/ManufacturerForm.vue 查看完整代码
<template>
  <form @submit.prevent="saveManufacturer">
    <div class="form-group">
      <label>Name</label>
      <input
        type="text"
        placeholder="Name"
        v-model="model.name"
        name="name"
        class="form-control" />
    </div>

    <div class="form-group new-button">
      <button class="button">
        <i class="fa fa-pencil"></i>
        <!-- Conditional rendering for input text -->
        <span v-if="isEditing">Update Manufacturer</span>
        <span v-else>Add Manufacturer</span>
      </button>
    </div>
  </form>
</template>

<script>
export default {
  props: ['model', 'isEditing'],
  methods: {
    saveManufacturer() {
      this.$emit('save-manufacturer', this.model)
    }
  }
}
</script>
```

该组件通过父子组件传值从父组件获取到了`model`和`isEditing`的值，并将`model`对象的信息展示在表单中。

表单信息中还通过`v-if`来判断`isEditing`的值是`true`还是`false`，如果是`true`则创建`Update Manufacturer`，反之创建`Add Manufacturer`。

当用户提交表单时触发`saveManufacturer`事件，此时会向父组件发送类型为`save-manufacturer`的事件通知其保存此次的修改操作。

### 重构 getters 文件

在创建编辑制造商组件之前，我们需要在getters文件中添加对应的getter属性。

我们在`src/store/getters.js`文件的`manufacturerGetters `对象中又添加了一个`manufacturerById`方法，用于获取本地中指定的制造商。

```js src/store/getters.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/store/getters.js 查看完整代码
// ...
export const manufacturerGetters = {
  allManufacturers(state) {
    return state.manufacturers;
[tuture-add]  },
[tuture-add]  manufacturerById: (state, getters) => id => {
[tuture-add]    if (getters.allManufacturers.length > 0) {
[tuture-add]      return getters.allManufacturers.filter(manufacturer => manufacturer._id === id)[0]
[tuture-add]    } else {
[tuture-add]      return state.manufacturer;
[tuture-add]    }
  }
}
```

`manufacturerById`方法中的id参数是Vue视图层通过方法调用时传入的id，通过这个id判断本地中是否存在该制造商，如果存在则返回该制造商，如果不存在则返回一个空对象。

### 创建 EditManufacturers 组件

在创建了展示制造商信息的表单组件`ManufacturerForm`以及添加了用于获取本地指定制造商数据的getter属性之后，紧接着我们又创建了`src/pages/admin/EditManufacturers.vue`文件，用于修改制造商信息。

```html src/pages/admin/EditManufacturers.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/pages/admin/EditManufacturers.vue 查看完整代码
<template>
  <manufacturer-form
    @save-manufacturer="addManufacturer"
    :model="model"
    :isEditing="true"
  >
  </manufacturer-form>
</template>

<script>
import ManufacturerForm from '@/components/ManufacturerForm.vue';
export default {
  created() {
    this.$store.dispatch('manufacturerById', {
      manufacturerId: this.$route.params['id']
    });
  },
  computed: {
    model() {
      const manufacturer = this.$store.getters.manufacturerById(this.$route.params['id']);

      // 这里返回 product 的拷贝，是为了在修改 product 的拷贝之后，在保存之前不修改本地 Vuex stire 的 product 属性
      return { ...manufacturer };
    }
  },
  methods: {
    addManufacturer(model) {
      this.$store.dispatch('updateManufacturer', {
        manufacturer: model,
      })
    },
  },
  components: {
  'manufacturer-form': ManufacturerForm
  }
}
</script>
```

该组件刚被创建时将当前处于激活状态的路由对象的id参数作为载荷分发到类型为`manufacturerById`的`action`中，在`action`中进行异步操作从服务器获取对应制造商，然后将该制造商提交到对应`mutation`中进行本地状态修改，将获取到的制造商保存到本地。

我们定义了计算属性`model`返回`manufacturer`的拷贝，是为了在修改`manufacturer`的拷贝之后，在保存之前不修改本地 `store`中的`manufacturer`属性。这里以方法访问的形式从`getters`中通过当前激活的路由对象中的id参数获取本地状态中的对应制造商作为`manufacturer`的拷贝，并返回给计算属性`model`，然后传给子组件`ManufacturerForm`。

该组件在`addManufacturer`事件中将子组件传入的新制造商对象作为载荷分发到类型为`updateManufacturer`的`action`中，在`action`中进行异步操作修改后端对应的商品信息，然后将新对象提交到对应的`mutation`中进行本地状态修改，修改本地状态中的`manufacturer`对象。

### 创建 NewManufacturers 组件

同样的我们继续创建了`src/pages/admin/NewManufacturers.vue`文件，用于添加制造商信息。该组件和添加商品信息组件代码逻辑类似。

```html src/pages/admin/NewManufacturers.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/pages/admin/NewManufacturers.vue 查看完整代码
<template>
  <manufacturer-form
    @save-manufacturer="addManufacturer"
    :model="model"
  >
  </manufacturer-form>
</template>

<script>
import ManufacturerForm from '@/components/ManufacturerForm.vue';
export default {
  computed: {
    model() {
      return {};
    }
  },
  methods: {
    addManufacturer(model) {
      this.$store.dispatch('addManufacturer', {
        manufacturer: model,
      })
    },
  },
  components: {
  'manufacturer-form': ManufacturerForm
  }
}
</script>
```

该组件逻辑代码与`New.vue`组件类似，一个是添加商品组件，一个是添加制造商组件，您可以对比着来看。

### 重构 Admin 入口文件

之前我们在该入口文件中增加了**查看生产商**导航，这里我们又增加了**添加生产商**导航。

```html src/pages/admin/Index.vue https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/pages/admin/Index.vue 查看完整代码
// ...
            <li>
              <router-link to="/admin/manufacturers">查看生产商</router-link>
            </li>
[tuture-add]            <li>
[tuture-add]              <router-link to="/admin/manufacturers/new">添加生产商</router-link>
[tuture-add]            </li>
          </ul>
        </div>
        <router-view></router-view>
      // ...
```

### 添加路由信息

我们已经创建了添加和修改制造商组件以及添加了对应的入口导航，接着我们需要在该文件中对其进行路由参数配置。

再次进入`src/router/index.js`文件，我们导入了添加制造商和修改制造商的组件并配置了相关路由参数。

```js src/router/index.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/router/index.js 查看完整代码
// ...
import Products from '@/pages/admin/Products';
import Edit from '@/pages/admin/Edit';
import Manufacturers from '@/pages/admin/Manufacturers';
[tuture-add]import NewManufacturers from '@/pages/admin/NewManufacturers';
[tuture-add]import EditManufacturers from '@/pages/admin/EditManufacturers';

Vue.use(Router);

// ...
          name: 'Manufacturers',
          component: Manufacturers,
        },
[tuture-add]        {
[tuture-add]          path: 'manufacturers/new',
[tuture-add]          name: 'NewManufacturers',
[tuture-add]          component: NewManufacturers,
[tuture-add]        },
[tuture-add]        {
[tuture-add]          path: 'manufacturers/edit/:id',
[tuture-add]          name: 'EditManufacturers',
[tuture-add]          component: EditManufacturers,
[tuture-add]        },
      ]
    },
    {
      // ...
```

这里添加制造商的路由配置就是静态路由的配置方式；修改制造商的路由配置采用了动态传参的方式，这里使用的是`$route.params`对象的`Post`方式传参。	

配置好添加制造商和修改制造商的路由参数之后，我们又可以进行验收啦，运行项目，点击Admin然后再点击添加制造商，我们可以看到添加制造商的表单：  

![](https://imgkr2.cn-bj.ufileos.com/75d2e9a0-99e1-48b7-bd69-7e3b02c2e1d5.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=X%252FJFSTrFlTYnf7d5tuQdt%252F%252FVlhA%253D&Expires=1597417641)

 然后再点击查看制造商，我们又可以看到一系列的制造商，并且每个制造商都对应的有修改和删除操作，这里我们随便选择一个制造商进行修改，就会看到该制造商的表单信息：  

![](https://imgkr2.cn-bj.ufileos.com/1ba7ff1c-472b-4aa2-987b-b9272906e773.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=xC1ZxIRtgoxTIFhTsb4EwxLf1P8%253D&Expires=1597417672)

### 创建 mutation-types 文件

这一节我们将对我们的项目代码进行优化，干掉一些硬编码。

我们都知道在`actions`文件和`mutations`文件中有一部分的事件类型是需要保持一致的，比如在我们在视图层分发一个添加商品事件`ADD_PRODUCT`，在`actions`文件中就需要有对应事件类型的`action`接收，然后向后端发起请求并将请求结果提交到对应类型的`mutation`中，这就要求了这几个文件中的对应事件类型都要保持一致。可是我们在开发过程中难免会出错，比如漏掉一个字母就会导致两个文件中的对应事件无法接收，尴尬的是控制台也没有报错，这就造成了我们很难查错。

因此，我们采用了字符串常量的形式定义`actions`文件和`mutations`文件中的事件类型，只要我们写错一个单词都会导致字符串常量不一致，关键的是这个时候会报错，利于我们查错。

进而我们创建了`src/store/mutation-types.js`文件，用于定义一些字符串常量来表示各种事件类型，并导出这些字符串常量。

```js src/store/mutation-types.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/store/mutation-types.js 查看完整代码
export const ALL_PRODUCTS = 'ALL_PRODUCTS';
export const ALL_PRODUCTS_SUCCESS = 'ALL_PRODUCTS_SUCCESS';

export const PRODUCT_BY_ID = 'PRODUCT_BY_ID';
export const PRODUCT_BY_ID_SUCCESS = 'PRODUCT_BY_ID_SUCCESS';

export const ADD_PRODUCT = 'ADD_PRODUCT';
export const ADD_PRODUCT_SUCCESS = 'ADD_PRODUCT_SUCCESS';

export const UPDATE_PRODUCT = 'UPDATE_PRODUCT';
export const UPDATE_PRODUCT_SUCCESS = 'UPDATE_PRODUCT_SUCCESS';

export const REMOVE_PRODUCT = 'REMOVE_PRODUCT';
export const REMOVE_PRODUCT_SUCCESS = 'REMOVE_PRODUCT_SUCCESS';

export const ADD_TO_CART = 'ADD_TO_CART';
export const REMOVE_FROM_CART = 'REMOVE_FROM_CART';

export const ALL_MANUFACTURERS = 'ALL_MANUFACTURER';
export const ALL_MANUFACTURERS_SUCCESS = 'ALL_MANUFACTURER_S';

export const MANUFACTURER_BY_ID = 'MANUFACTURER_BY_ID';
export const MANUFACTURER_BY_ID_SUCCESS = 'MANUFACTURER_BY_ID_SUCCESS';

export const ADD_MANUFACTURER = 'ADD_MANUFACTURER';
export const ADD_MANUFACTURER_SUCCESS = 'ADD_MANUFACTURER_SUCCESS';

export const UPDATE_MANUFACTURER = 'UPDATE_MANUFACTURER';
export const UPDATE_MANUFACTURER_SUCCESS = 'UPDATE_MANUFACTURER_SUCCESS';

export const REMOVE_MANUFACTURER = 'REMOVE_MANUFACTURER';
export const REMOVE_MANUFACTURER_SUCCESS = 'REMOVE_MANUFACTURER_SUCCESS';
```

### 重构 actions 文件

我们再次来到`src/store/actions.js`文件中，将所有的事件类型用字符串常量表示。

```js src/store/actions.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/store/actions.js 查看完整代码
import axios from 'axios';

[tuture-add]import {
[tuture-add]  ADD_PRODUCT,
[tuture-add]  ADD_PRODUCT_SUCCESS,
[tuture-add]  PRODUCT_BY_ID,
[tuture-add]  PRODUCT_BY_ID_SUCCESS,
[tuture-add]  UPDATE_PRODUCT,
[tuture-add]  UPDATE_PRODUCT_SUCCESS,
[tuture-add]  REMOVE_PRODUCT,
[tuture-add]  REMOVE_PRODUCT_SUCCESS,
[tuture-add]  ALL_PRODUCTS,
[tuture-add]  ALL_PRODUCTS_SUCCESS,
[tuture-add]  ALL_MANUFACTURERS,
[tuture-add]  ALL_MANUFACTURERS_SUCCESS,
[tuture-add]  MANUFACTURER_BY_ID,
[tuture-add]  MANUFACTURER_BY_ID_SUCCESS,
[tuture-add]  ADD_MANUFACTURER,
[tuture-add]  ADD_MANUFACTURER_SUCCESS,
[tuture-add]  UPDATE_MANUFACTURER,
[tuture-add]  UPDATE_MANUFACTURER_SUCCESS,
[tuture-add]  REMOVE_MANUFACTURER,
[tuture-add]  REMOVE_MANUFACTURER_SUCCESS,
[tuture-add]} from './mutation-types';
[tuture-add] 
const API_BASE = 'http://localhost:3000/api/v1';

export const productActions = {
  allProducts({ commit }) {
[tuture-del]    commit('ALL_PRODUCTS')
[tuture-add]    commit(ALL_PRODUCTS)

    axios.get(`${API_BASE}/products`).then(response => {
[tuture-del]      commit('ALL_PRODUCTS_SUCCESS', {
[tuture-add]      commit(ALL_PRODUCTS_SUCCESS, {
        products: response.data,
      });
    })
  },
  productById({ commit }, payload) {
[tuture-del]    commit('PRODUCT_BY_ID');
[tuture-add]    commit(PRODUCT_BY_ID);

    const { productId } = payload;
    axios.get(`${API_BASE}/products/${productId}`).then(response => {
[tuture-del]      commit('PRODUCT_BY_ID_SUCCESS', {
[tuture-add]      commit(PRODUCT_BY_ID_SUCCESS, {
        product: response.data,
      });
    })
  },
  removeProduct({ commit }, payload) {
[tuture-del]    commit('REMOVE_PRODUCT');
[tuture-add]    commit(REMOVE_PRODUCT);

    const { productId } = payload;
    axios.delete(`${API_BASE}/products/${productId}`).then(() => {
      // 返回 productId，用于删除本地对应的商品
[tuture-del]      commit('REMOVE_PRODUCT_SUCCESS', {
[tuture-add]      commit(REMOVE_PRODUCT_SUCCESS, {
        productId,
      });
    })
  },
  updateProduct({ commit }, payload) {
[tuture-del]    commit('UPDATE_PRODUCT');
[tuture-add]    commit(UPDATE_PRODUCT);

    const { product } = payload;
    axios.put(`${API_BASE}/products/${product._id}`, product).then(() => {
[tuture-del]      commit('UPDATE_PRODUCT_SUCCESS', {
[tuture-add]      commit(UPDATE_PRODUCT_SUCCESS, {
        product,
      });
    })
  },
  addProduct({ commit }, payload) {
[tuture-del]    commit('ADD_PRODUCT');
[tuture-add]    commit(ADD_PRODUCT);

    const { product } = payload;
    axios.post(`${API_BASE}/products`, product).then(response => {
[tuture-del]      commit('ADD_PRODUCT_SUCCESS', {
[tuture-add]      commit(ADD_PRODUCT_SUCCESS, {
        product: response.data,
      })
    })
  // ...

export const manufacturerActions = {
  allManufacturers({ commit }) {
[tuture-del]    commit('ALL_MANUFACTURERS');
[tuture-add]    commit(ALL_MANUFACTURERS);

    axios.get(`${API_BASE}/manufacturers`).then(response => {
[tuture-del]      commit('ALL_MANUFACTURERS_SUCCESS', {
[tuture-add]      commit(ALL_MANUFACTURERS_SUCCESS, {
        manufacturers: response.data,
      });
    })
  },
[tuture-add]  manufacturerById({ commit }, payload) {
[tuture-add]    commit(MANUFACTURER_BY_ID);
[tuture-add] 
[tuture-add]    const { manufacturerId } = payload;
[tuture-add]    axios.get(`${API_BASE}/manufacturers/${manufacturerId}`).then(response => {
[tuture-add]      commit(MANUFACTURER_BY_ID_SUCCESS, {
[tuture-add]        manufacturer: response.data,
[tuture-add]      });
[tuture-add]    })
[tuture-add]  },
  removeManufacturer({ commit }, payload) {
[tuture-del]    commit('REMOVE_MANUFACTURER');
[tuture-add]    commit(REMOVE_MANUFACTURER);

    const { manufacturerId } = payload;
    axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() => {
      // 返回 manufacturerId，用于删除本地对应的制造商
[tuture-del]      commit('REMOVE_MANUFACTURER_SUCCESS', {
[tuture-add]      commit(REMOVE_MANUFACTURER_SUCCESS, {
        manufacturerId,
      });
    })
  },
[tuture-add]  updateManufacturer({ commit }, payload) {
[tuture-add]    commit(UPDATE_MANUFACTURER);
[tuture-add] 
[tuture-add]    const { manufacturer } = payload;
[tuture-add]    axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer).then(() => {
[tuture-add]      commit(UPDATE_MANUFACTURER_SUCCESS, {
[tuture-add]        manufacturer,
[tuture-add]      });
[tuture-add]    })
[tuture-add]  },
[tuture-add]  addManufacturer({ commit }, payload) {
[tuture-add]    commit(ADD_MANUFACTURER);
[tuture-add] 
[tuture-add]    const { manufacturer } = payload;
[tuture-add]    axios.post(`${API_BASE}/manufacturers`, manufacturer).then(response => {
[tuture-add]      commit(ADD_MANUFACTURER_SUCCESS, {
[tuture-add]        manufacturer: response.data,
[tuture-add]      })
[tuture-add]    })
[tuture-add]  }
}
```

这里我们首先导入了`mutation-types`文件中定义的一些字符串常量，替换掉了对应的事件类型。

### 重构 mutations 文件

同actions文件一样，我们再次进入`src/store/mutations.js`文件，将文件中的各种事件类型用字符串常量替代。

```js src/store/mutations.js https://github.com/tuture-dev/vue-online-shop-frontend/blob/49571dc/src/store/mutations.js 查看完整代码
[tuture-add]import {
[tuture-add]  ADD_PRODUCT,
[tuture-add]  ADD_PRODUCT_SUCCESS,
[tuture-add]  PRODUCT_BY_ID,
[tuture-add]  PRODUCT_BY_ID_SUCCESS,
[tuture-add]  UPDATE_PRODUCT,
[tuture-add]  UPDATE_PRODUCT_SUCCESS,
[tuture-add]  REMOVE_PRODUCT,
[tuture-add]  REMOVE_PRODUCT_SUCCESS,
[tuture-add]  ADD_TO_CART,
[tuture-add]  REMOVE_FROM_CART,
[tuture-add]  ALL_PRODUCTS,
[tuture-add]  ALL_PRODUCTS_SUCCESS,
[tuture-add]  ALL_MANUFACTURERS,
[tuture-add]  ALL_MANUFACTURERS_SUCCESS,
[tuture-add]  MANUFACTURER_BY_ID,
[tuture-add]  MANUFACTURER_BY_ID_SUCCESS,
[tuture-add]  ADD_MANUFACTURER,
[tuture-add]  ADD_MANUFACTURER_SUCCESS,
[tuture-add]  UPDATE_MANUFACTURER,
[tuture-add]  UPDATE_MANUFACTURER_SUCCESS,
[tuture-add]  REMOVE_MANUFACTURER,
[tuture-add]  REMOVE_MANUFACTURER_SUCCESS,
[tuture-add]} from './mutation-types';
[tuture-add] 
[tuture-add] 
export const productMutations = {
[tuture-del]  ALL_PRODUCTS(state) {
[tuture-add]  [ALL_PRODUCTS](state) {
    state.showLoader = true;
  },
[tuture-del]  ALL_PRODUCTS_SUCCESS(state, payload) {
[tuture-add]  [ALL_PRODUCTS_SUCCESS](state, payload) {
    const { products } = payload;

    state.showLoader = false;
    state.products = products;
  },
[tuture-del]  PRODUCT_BY_ID(state) {
[tuture-add]  [PRODUCT_BY_ID](state) {
    state.showLoader = true;
  },
[tuture-del]  PRODUCT_BY_ID_SUCCESS(state, payload) {
[tuture-add]  [PRODUCT_BY_ID_SUCCESS](state, payload) {
    state.showLoader = false;

    const { product } = payload;
    state.product = product;
  },
[tuture-del]  REMOVE_PRODUCT(state) {
[tuture-add]  [REMOVE_PRODUCT](state) {
    state.showLoader = true;
  },
[tuture-del]  REMOVE_PRODUCT_SUCCESS(state, payload) {
[tuture-add]  [REMOVE_PRODUCT_SUCCESS](state, payload) {
    state.showLoader = false;

    const { productId } = payload;
    state.products = state.products.filter(product => product._id !== productId);
  },
[tuture-del]  UPDATE_PRODUCT(state) {
[tuture-add]  [UPDATE_PRODUCT](state) {
    state.showLoader = true;
  },
[tuture-del]  UPDATE_PRODUCT_SUCCESS(state, payload) {
[tuture-add]  [UPDATE_PRODUCT_SUCCESS](state, payload) {
    state.showLoader = false;

    const { product: newProduct } = payload;
    // ...
      return product;
    })
  },
[tuture-del]  ADD_PRODUCT(state) {
[tuture-add]  [ADD_PRODUCT](state) {
    state.showLoader = true;
  },
[tuture-del]  ADD_PRODUCT_SUCCESS(state, payload) {
[tuture-add]  [ADD_PRODUCT_SUCCESS](state, payload) {
    state.showLoader = false;

    const { product } = payload;
    // ...
};

export const cartMutations = {
[tuture-del]  ADD_TO_CART(state, payload) {
[tuture-add]  [ADD_TO_CART](state, payload) {
    const { product } = payload;
    state.cart.push(product)
  },
[tuture-del]  REMOVE_FROM_CART(state, payload) {
[tuture-add]  [REMOVE_FROM_CART](state, payload) {
    const { productId } = payload
    state.cart = state.cart.filter(product => product._id !== productId)
  },
[tuture-del]}
[tuture-add]};

export const manufacturerMutations = {
[tuture-del]  ALL_MANUFACTURERS(state) {
[tuture-add]  [ALL_MANUFACTURERS](state) {
    state.showLoader = true;
  },
[tuture-del]  ALL_MANUFACTURERS_SUCCESS(state, payload) {
[tuture-add]  [ALL_MANUFACTURERS_SUCCESS](state, payload) {
    const { manufacturers } = payload;

    state.showLoader = false;
    state.manufacturers = manufacturers;
  },
[tuture-del]  REMOVE_MANUFACTURER(state) {
[tuture-add]  [MANUFACTURER_BY_ID](state) {
    state.showLoader = true;
  },
[tuture-del]  REMOVE_MANUFACTURER_SUCCESS(state, payload) {
[tuture-add]  [MANUFACTURER_BY_ID_SUCCESS](state, payload) {
[tuture-add]    state.showLoader = false;
[tuture-add] 
[tuture-add]    const { manufacturer } = payload;
[tuture-add]    state.manufacturer = manufacturer;
[tuture-add]  },
[tuture-add]  [REMOVE_MANUFACTURER](state) {
[tuture-add]    state.showLoader = true;
[tuture-add]  },
[tuture-add]  [REMOVE_MANUFACTURER_SUCCESS](state, payload) {
    state.showLoader = false;

    const { manufacturerId } = payload;
    state.manufacturers = state.manufacturers.filter(manufacturer => manufacturer._id !== manufacturerId);
[tuture-add]  },
[tuture-add]  [UPDATE_MANUFACTURER](state) {
[tuture-add]    state.showLoader = true;
[tuture-add]  },
[tuture-add]  [UPDATE_MANUFACTURER_SUCCESS](state, payload) {
[tuture-add]    state.showLoader = false;
[tuture-add] 
[tuture-add]    const { manufacturer: newManufacturer } = payload;
[tuture-add]    state.manufacturers = state.manufacturers.map(manufacturer => {
[tuture-add]      if (manufacturer._id === newManufacturer._id) {
[tuture-add]        return newManufacturer;
[tuture-add]      }
[tuture-add] 
[tuture-add]      return manufacturer;
[tuture-add]    })
[tuture-add]  },
[tuture-add]  [ADD_MANUFACTURER](state) {
[tuture-add]    state.showLoader = true;
[tuture-add]  },
[tuture-add]  [ADD_MANUFACTURER_SUCCESS](state, payload) {
[tuture-add]    state.showLoader = false;
[tuture-add] 
[tuture-add]    const { manufacturer } = payload;
[tuture-add]    state.manufacturers = state.manufacturers.concat(manufacturer);
  }
}
```

这里我们首先导入了`mutation-types`文件中定义的一些字符串常量，替换掉了对应的事件类型。

### 小结

这一节我们主要做了以下工作：

- 创建了制造商相关组件并配置了相应路由参数，实现了新建和修改制造商信息；
- 利用字符串常量代替actions文件和mutations文件中的事件类型；

## 大量改进最后一步内容